{"version":3,"sources":["_tactical.js","_enemies.js","_friendlies.js","_game.js","_build.js","_server.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["const Tactical = function(name, cssClass, description) {\n  this.name = name;\n  this.cssClass = cssClass;\n  this.description = description;\n  this.type = \"basic\";\n  this.card = \"<li class='tactical \" + this.cssClass + \"'>\"\n            + \"<h3>\" + this.name + \"</h3>\"\n            + \"<p>\" + this.description + \"</p>\"\n            + \"</li>\";\n}\n\nconst AdvTactical = function(name, cssClass, description, cost) {\n  Tactical.call(this, name, cssClass, description);\n  this.cost = cost;\n  this.type = \"advanced\";\n  this.card = \"<li class='advTactical \" + this.cssClass + \"'>\"\n              + \"<h3>\" + this.name + \"</h3>\"\n              + \"<p>\" + this.description + \"</p>\"\n              + \"<p class='cost'>Merit cost: \" + this.cost + \"</p>\"\n              + \"</li>\"\n}\nAdvTactical.prototype = Object.create(Tactical.prototype);\n\nAdvTactical.prototype.generateCard = function(player) {\n  if (player.merit >= this.cost) {\n    return \"<li class='advTactical \" + this.cssClass + \" purchasable'>\"\n            + \"<h3>\" + this.name + \"</h3>\"\n            + \"<p>\" + this.description + \"</p>\"\n            + \"<p class='cost'> Merit cost: \" + this.cost + \"</p>\"\n            + \"</li>\";\n  } else {\n    return \"<li class='advTactical \" + this.cssClass + \" unavailable'>\"\n            + \"<h3>\" + this.name + \"</h3>\"\n            + \"<p>\" + this.description + \"</p>\"\n            + \"<p class='cost'> Merit cost: \" + this.cost + \"</p>\"\n            + \"</li>\";\n  }\n}\n","const EnemyBase = function() {\n  this.id = \"enemyBase\";\n  this.name = \"Enemy Base\";\n  this.maxArmor = 30;\n  this.currentArmor = 30;\n  this.enemyBaseDeck = {\n    name: \"Enemy Base Deck\",\n    cards: [],\n    discard: [],\n  };\n  this.enemyBaseCardsPerTurn = 1;\n  this.currentEnemyBaseCard = [];\n  this.enemyDeck = {\n    name: \"Enemy Deck\",\n    cards: [],\n    discard: []\n  };\n  this.enemiesActive = [];\n  this.enemiesPerTurn;\n  this.effects = {\n    jammed: false,\n    intercepted: false,\n    deploy: false\n  }\n  this.summary = \"<h3>\" + this.name + \"</h3>\"\n          + \"<p>Armor: \" + this.currentArmor + \"/\" + this.maxArmor + \"</p>\"\n          + \"<p>Launch rate: \" + this.enemiesPerTurn + \"</p>\";\n}\n\nEnemyBase.prototype.updateSummary = function() {\n  if (game.roundNumber === 1) {\n    this.summary = \"<h3>\" + this.name + \"</h3>\"\n                    + \"<p>Armor: \" + this.currentArmor + \"/\"\n                    + this.maxArmor + \"</p>\"\n                    + \"<p>Launch rate: \" + this.enemiesPerTurn + \"</p>\";\n  } else if (this.currentEnemyBaseCard.length === 0 && game.roundNumber > 1) {\n    this.summary = \"<h3>\" + this.name + \"</h3>\"\n                    + \"<p>Armor: \" + this.currentArmor + \"/\"\n                    + this.maxArmor + \"</p>\"\n                    + \"<p>Launch rate: \" + this.enemiesPerTurn + \"</p>\"\n                    + \"<div class='enemyBaseCard'><h3>Jammed</h3></div>\";\n  } else {\n    this.summary = \"<h3>\" + this.name + \"</h3>\"\n                    + \"<p>Armor: \" + this.currentArmor + \"/\"\n                    + this.maxArmor + \"</p>\"\n                    + \"<p>Launch rate: \" + this.enemiesPerTurn + \"</p>\"\n                    + this.currentEnemyBaseCard[0].card;\n  }\n}\n\nEnemyBase.prototype.takeDamage = function(damage) {\n  this.currentArmor -= damage;\n  if (this.currentArmor < 0) {\n    this.currentArmor = 0;\n  }\n  if (this.currentArmor === 0) {\n    io.sockets.emit(\"msg\", this.name + \" destroyed! Players win.\");\n    game.win = true;\n  }\n  this.updateSummary();\n}\n\nEnemyBase.prototype.addEnemy = function() {\n  game.checkDeck(this.enemyDeck);\n  this.enemiesActive.push(this.enemyDeck.cards.pop());\n}\n\nEnemyBase.prototype.replaceEnemyBaseCard = function() {\n  if (this.effects.jammed === true) {\n    this.enemyBaseDeck.discard.push(this.currentEnemyBaseCard.pop());\n    this.effects.jammed = false;\n  } else {\n    game.replaceCards(this.enemyBaseCardsPerTurn, this.enemyBaseDeck,\n                      this.currentEnemyBaseCard);\n    let ebCard = this.currentEnemyBaseCard[0];\n    this[ebCard.cssClass]();\n  }\n}\n\n\n/************************\nENEMY BASE CARD FUNCTIONS\n*************************/\n\nEnemyBase.prototype.reinforce = function() {\n  io.sockets.emit(\"msg\", this.name + \" will launch one extra enemy card into play each round.\");\n  this.enemiesPerTurn += 1;\n}\n\nEnemyBase.prototype.repair = function() {\n  this.currentArmor += 5;\n  if (this.currentArmor > this.maxArmor) {\n    this.currentArmor = this.maxArmor;\n  }\n  io.sockets.emit(\"msg\", this.name + \" Repairs 5 damage. Current armor: \"\n              + this.currentArmor + \"/\" + this.maxArmor);\n}\n\nEnemyBase.prototype.fireHeavy = function() {\n  io.sockets.emit(\"msg\", this.name + \" fires heavy weapons.\");\n  FriendlyBase.takeDamage(5);\n}\n\nEnemyBase.prototype.fireLight = function() {\n  io.sockets.emit(\"msg\", this.name + \" fires light weapons.\");\n  FriendlyBase.takeDamage(3);\n}\n\nEnemyBase.prototype.deploy = function() {\n  io.sockets.emit(\"msg\", this.name + \" launches an extra fighter.\");\n  this.effects.deploy = true;\n}\n\nconst Enemy = function(name, cssClass, armor, power, targeting, merit) {\n  this.name = name;\n  this.cssClass = cssClass;\n  this.armor = armor;\n  this.currentArmor = this.armor;\n  this.power = power;\n  this.targeting = targeting;\n  this.merit = merit;\n  if (this.cssClass === \"emptySpace\" || this.cssClass === \"destroyed\") {\n    this.card = \"<li class='enemy \" + this.cssClass + \"'>\";\n              + \"<h3>\" + this.name + \"</h3>\"\n              + \"</li>\";\n  } else {\n    this.card = \"<li class='enemy \" + this.cssClass + \"'>\"\n            + \"<h3>\" + this.name + \"</h3>\"\n            + \"<p>ARM: \" + this.currentArmor + \"/\" + this.armor + \"</p>\"\n            + \"<p>PWR: \" + this.power + \"</p>\"\n            + \"<p>TGT: \" + this.targeting + \"</p>\"\n            + \"<p>MRT: \" + this.merit + \"</p>\"\n            + \"</li>\";\n  }\n}\n\nEnemy.prototype.takeDamage = function(damage) {\n  this.currentArmor -= damage;\n  if (this.currentArmor < 0) {\n    this.currentArmor = 0;\n  }\n  this.updateCard();\n}\n\nEnemy.prototype.resetArmor = function() {\n  this.currentArmor = this.armor;\n}\n\nconst EnemyBaseCard = function(name, cssClass, description) {\n  this.name = name;\n  this.cssClass = cssClass;\n  this.description = description;\n  this.card = \"<p id='enemyBaseCard'>\" + this.description + \"</p>\";\n}\n","//IF MIGRATED TO SERVER SIDE\n// let enemies = require(\"./enemies\");\n// let tactical = require(\"./tactical\");\n\n\n/**************************\nFRIENDLY BASE CONSTRUCTOR\n**************************/\n\nconst Friendly = function(id, name, maxArmor) {\n  this.id = id;\n  this.name = name;\n  this.maxArmor = maxArmor;\n  this.pursuers = [];\n  this.pursuerDamage = [];\n  this.effects = {\n    dead: false,\n    medalOfHonor: false,\n    medic: false,\n    daredevil: false,\n    sharpShooter: false,\n    emp: false,\n    countermeasures: false,\n    divertShields: 0,\n    status: \"Pursued\"\n  };\n  this.market = [];\n  this.marketSize = 4;\n  this.advTactics = {\n    name: \"Advanced tactics\",\n    cards: [],\n    discard: []\n  };\n  this.currentArmor = maxArmor;\n  this.summary = \"<h3>\" + this.name + \"</h3>\"\n            + \"<p>Armor: \" + this.currentArmor + \"/\" + this.maxArmor + \"</p>\"\n            + \"<p class='pursued'>\" + this.effects.status + \"</p>\";\n}\n\n\n\n/**************************\nFRIENDLY BASE UTILITY METHODS\n**************************/\n\nFriendly.prototype.adjustPursuerDamage = function() { // Player should inherit\n  while (this.pursuerDamage.length < this.pursuers.length) {\n    this.pursuerDamage.push(0);\n  }\n  while (this.pursuerDamage.length > this.pursuers.length) {\n    this.pursuerDamage.pop();\n  }\n}\n\nFriendly.prototype.updateSummary = function() {\n  this.effects.status = \"Free\";\n  this.summary = \"<h3>\" + this.name + \"</h3>\"\n            + \"<p>Armor: \" + this.currentArmor + \"/\" + this.maxArmor + \"</p>\";\n  for (let i=0; i<this.pursuers.length; i++) {\n    let enemy = this.pursuers[i];\n    if (enemy.merit > 0) {\n      this.effects.status = \"Pursued\";\n    }\n  }\n  if (this.effects.status === \"Pursued\") {\n    this.summary += \"<p class='pursued'>\" + this.effects.status + \"</p>\";\n  } else {\n    this.summary += \"<p class='free'>\" + this.effects.status + \"</p>\";\n  }\n}\n\nFriendly.prototype.removeAdvTactic = function(index) {\n  game.moveCard(index, this.market, game.tacticalDeck.discard);\n}\n\nFriendly.prototype.addAdvTactic = function() {\n  let addToMarket = this.marketSize - this.market.length;\n  for (let i = 0; i < addToMarket; i++) {\n    game.checkDeck(this.advTactics);\n    this.market.push(this.advTactics.cards.pop());\n  }\n}\n\nFriendly.prototype.checkShields = function(damage) {\n  if (this.effects.divertShields > 0) {\n    let difference = this.effects.divertShields - damage;\n    if (difference > 0) {\n      this.effects.divertShields -= damage;\n      damage = 0;\n    } else if (difference < 0) {\n      damage -= this.effects.divertShields;\n      this.effects.divertShields = 0;\n    } else {\n      damage = 0;\n      this.effects.divertShields = 0;\n    }\n    io.sockets.emit(\"msg\", this.name + \"'s shields reduce damage to \"\n                + damage);\n  }\n  return damage;\n}\n\nFriendly.prototype.checkDamageNegation = function(damage) {\n  if (this.effects.emp) {\n    io.sockets.emit(\"msg\", this.name + \" is protected by EMP.\");\n    this.effects.emp = false;\n    return 0;\n  } else {\n    return damage;\n  }\n}\n\nFriendly.prototype.takeDamage = function(damage) {\n  // take damage\n  if (damage > 0) {\n    this.currentArmor -= damage;\n    if (this.currentArmor < 0) {\n      this.currentArmor = 0;\n    }\n    if (this.currentArmor === 0) {\n      io.sockets.emit(\"msg\", this.name + \" has been destroyed. Players lose.\");\n      this.effects.dead = true;\n      game.lose = true;\n    } else {\n      io.sockets.emit(\"msg\", this.name + \" takes \" + damage + \" damage. Current armor: \"\n                  + this.currentArmor + \"/\" + this.maxArmor);\n    }\n  }\n}\n\nFriendly.prototype.insertPlaceholder = function(index) { // Player should inherit\n  //removes an enemy card from the fray and inserts a \"destroyed\" place holder\n  this.pursuers.splice(index, 0, placeHolder);\n  this.pursuers.join();\n}\n\n\n\n/**************************\nPLAYER CONSTRUCTOR\n**************************/\n\nconst Player = function(id, name) {\n  this.id = id;\n  this.name = name;\n  this.maxArmor = 10;\n  this.currentArmor = this.maxArmor;\n  this.tacticalCardsPerTurn = 3;\n  this.lastCardUsed = null;\n  this.hand = [];\n  this.pursuers = [];\n  this.pursuerDamage = [];\n  this.merit = 0;\n  this.combatDie = [0,0,0,1,1,2];\n  this.improvedDie = [0,0,1,1,1,2];\n  this.missileDie = [0,0,1,1,2,2];\n  this.amtImproved = 0;\n  this.effects = {\n    dead: false,\n    medalOfHonor: false,\n    medic: false,\n    daredevil: false,\n    sharpShooter: false,\n    emp: false,\n    countermeasures: false,\n    divertShields: 0,\n    incinerator: false,\n    status: \"Pursued\"\n  };\n  this.summary = \"<h3>\" + this.name + \"</h3>\"\n                + \"<p>Armor: \" + this.currentArmor + \"/\"\n                + this.maxArmor + \"</p>\"\n                + \"<p>Merit: \" + this.merit + \"</p>\"\n                + \"<p class='pursued'>\" + this.effects.status + \"</p>\";\n}\n\n\n\n/**************************\nPLAYER UTILITY METHODS\n**************************/\n\n\n\nPlayer.prototype.insertPlaceholder = Friendly.prototype.insertPlaceholder;\nPlayer.prototype.checkShields = Friendly.prototype.checkShields;\nPlayer.prototype.adjustPursuerDamage = Friendly.prototype.adjustPursuerDamage;\n\nPlayer.prototype.resetCardsUsed = function() {\n  this.lastCardUsed = null;\n}\n\nPlayer.prototype.updateSummary = function() {\n  this.summary = \"<h3>\" + this.name + \"</h3>\";\n  if (!this.effects.dead) {\n    this.effects.status = \"Free\";\n    this.summary += \"<p>Armor: \" + this.currentArmor\n                  + \"/\" + this.maxArmor + \"</p>\"\n                  + \"<p>Merit: \" + this.merit + \"</p>\";\n    for (let i=0; i<this.pursuers.length; i++) {\n      let enemy = this.pursuers[i];\n      if (enemy.merit > 0) {\n        this.effects.status = \"Pursued\";\n      }\n    }\n  }\n  if (this.effects.status === \"Pursued\" || this.effects.status === \"KIA\") {\n    this.summary += \"<p class='pursued'>\" + this.effects.status + \"</p>\";\n  } else {\n    this.summary += \"<p class='free'>\" + this.effects.status + \"</p>\";\n  }\n}\n\nPlayer.prototype.setAmtImproved = function() {\n  // set interval for the amount of improved dice\n  this.amtImproved = Math.floor(this.merit/5);\n}\n\nPlayer.prototype.damageRoll = function(list) {\n  // return a random value from a list\n  return list[Math.floor(Math.random() * list.length)];\n}\n\nPlayer.prototype.increaseMerit = function(amount) {\n  let merit = amount;\n  if (this.effects.medalOfHonor === true) {\n    merit += 1;\n  }\n  this.merit += merit;\n  io.sockets.emit(\"msg\", this.name + \" receives \" + merit + \" merit.\");\n}\n\n// calculate damage // only returning 0\nPlayer.prototype.calcDamage = function(dice) {\n  // roll a combat die x times and add the rolls together\n  let totalRolls = dice;\n  let improvedRolls = this.amtImproved;\n  let normalRolls = totalRolls - improvedRolls;\n  let damage = 0;\n  while (normalRolls > 0) {\n      damage += this.damageRoll(this.combatDie);\n      normalRolls--;\n    }\n  while (improvedRolls > 0) {\n      damage += this.damageRoll(this.improvedDie);\n      improvedRolls--;\n    }\n    return damage;\n}\n\nPlayer.prototype.checkDamageNegation = function(damage) {\n  if (damage > 0) {\n    if (this.effects.emp) {\n      io.sockets.emit(\"msg\", this.name + \" is protected by EMP.\");\n      this.effects.emp = false;\n      return 0;\n    } else {\n      damage = this.checkShields(damage);\n      if (this.effects.countermeasures) {\n        let counterDamage = this.calcDamage(4);\n        io.sockets.emit(\"msg\", this.name + \" deploys countermeasures to avoid \"\n                    + counterDamage + \" damage.\");\n        damage -= counterDamage;\n        this.effects.countermeasures = false;\n      }\n      if (damage < 0) {\n        damage = 0;\n        io.sockets.emit(\"msg\", \"All damage to \" + this.name + \" negated.\");\n      } else {\n        return damage;\n      }\n    }\n  } else {\n    return damage;\n  }\n}\n\nPlayer.prototype.takeDamage = function(damage) {\n  if (damage > 0) {\n    this.currentArmor -= damage;\n    if (this.currentArmor <= 0) {\n      this.currentArmor = 0;\n      this.effects.dead = true;\n      this.effects.status = \"KIA\";\n      io.sockets.emit(\"msg\", this.name + \" takes \" + damage + \" damage. \" + this.name + \" has been destroyed.\");\n      while (this.hand.length > 0) {\n        game.moveCard(0, this.hand, game.tacticalDeck.discard);\n      }\n      let pursuers = this.pursuers;\n      game.distributeEnemies(pursuers);\n      this.pursuers = [];\n      let alldead = true;\n      for (let i = 0; i < game.friendlies.length; i++) {\n        let friendly = game.friendlies[i];\n        if (friendly.id === \"FriendlyBase\") {\n          continue;\n        } else {\n          if (!friendly.effects.dead) {\n            alldead = false;\n          }\n        }\n      }\n      if (alldead) {\n        io.sockets.emit(\"msg\", \"All pilots destroyed. Players lose.\");\n        game.lose = true;\n      }\n    } else {\n      io.sockets.emit(\"msg\", this.name + \" takes \" + damage + \" damage. Current armor: \"\n                  + this.currentArmor + \"/\" + this.maxArmor);\n    }\n  }\n}\n\nPlayer.prototype.checkKill = function(friendly, index) {\n  // if kill: award merit, insert placeholder\n  if (friendly.pursuerDamage[index] >= friendly.pursuers[index].armor) {\n    io.sockets.emit(\"msg\", friendly.pursuers[index].name + \" pursuing \" + friendly.name\n                + \" destroyed.\")\n    this.increaseMerit(friendly.pursuers[index].merit);\n    game.moveCard(index, friendly.pursuers, enemyBase.enemyDeck.discard);\n    friendly.insertPlaceholder(index);\n  }\n}\n\nPlayer.prototype.doDamage = function(friendly, index, damage) {\n  // if damage is more than 0, deal damage to a selected enemy, check for kill\n  // does not allow damage to empty space or place holders\n  if (friendly === undefined) {\n    friendly = this;\n  }\n  if (index === undefined) {\n    index = 0;\n  }\n  if (friendly === enemyBase) {\n    if (damage > 0) {\n      enemyBase.takeDamage(damage);\n      io.sockets.emit(\"msg\", this.name + \" deals \" + damage + \" damage to enemy base.\");\n      this.increaseMerit(1);\n    } else {\n      io.sockets.emit(\"msg\", \"No damage to enemy base\");\n    }\n  } else {\n    if (friendly.pursuers[index] === empty\n      || friendly.pursuers[index] === placeHolder) {\n      console.error(\"No enemy at index \" + index);\n    } else {\n      if (damage > 0) {\n        friendly.pursuerDamage[index] += damage;\n        let enemyArmor = friendly.pursuers[index].armor - friendly.pursuerDamage[index];\n        if (enemyArmor < 0) {\n          enemyArmor = 0;\n        }\n        io.sockets.emit(\"msg\", this.name + \" deals \" + damage + \" damage to \"\n                    + friendly.pursuers[index].name + \" pursuing \"\n                    + friendly.name + \". Current armor: \"\n                    + enemyArmor\n                    + \"/\" + friendly.pursuers[index].armor);\n        this.checkKill(friendly, index);\n      } else {\n        io.sockets.emit(\"msg\", \"No damage to target.\");\n      }\n    }\n  }\n}\n\n\n\n/**************************\nPLAYER TACTICAL FUNCTIONS\n**************************/\n\nPlayer.prototype.fire = function(friendly, pursuerIndex) {\n  // deal damage equal to 4 combat dice to target\n  let damage = this.calcDamage(4);\n  this.doDamage(friendly, pursuerIndex, damage);\n}\n\nPlayer.prototype.evade = function(friendly, pursuerIndex) {\n  if (friendly === undefined) {\n    friendly = this;\n  }\n  // choose a target and attempt evade (D6 vs. enemy targeting)\n  let evadeRoll = Math.floor(Math.random() * 6) + 1;\n  let pursuer = this.pursuers[pursuerIndex];\n  if (evadeRoll >= pursuer.targeting) {\n    io.sockets.emit(\"msg\", this.name + \" shakes \" + pursuer.name + \" to friendly base.\");\n    game.moveCard(pursuerIndex, this.pursuers, FriendlyBase.pursuers);\n    game.moveCard(pursuerIndex, this.pursuerDamage, FriendlyBase.pursuerDamage);\n    this.insertPlaceholder(pursuerIndex);\n    this.adjustPursuerDamage();\n    FriendlyBase.adjustPursuerDamage();\n  } else {\n    io.sockets.emit(\"msg\", this.name + \" can't shake 'em!\")\n  }\n}\n\nPlayer.prototype.missile = function(friendly, pursuerIndex) {\n  // deal damage equal to 5 combat dice to target\n  let damage = this.calcDamage(4) + this.damageRoll(this.missileDie);\n  this.doDamage(friendly, pursuerIndex, damage);\n}\n\nPlayer.prototype.heatSeeker = function(friendly, pursuerIndex) {\n  // deal 5 damage to target\n  this.doDamage(friendly, pursuerIndex, 5);\n}\n\nPlayer.prototype.bomb = function(friendly, pursuerIndex, damage, collateral) { // throwing error when attack enemyBase\n    // deal 6 damage to target and 2 damage to each adjacent targeting\n    // if there is no adjacent target, collateral damage is applied to pursued ally\n    // flat 10 damage to enemyBase\n    if (pursuerIndex === undefined) {\n      pursuerIndex = 0;\n    }\n    if (damage === undefined) {\n      damage = 6;\n    }\n    if (collateral === undefined) {\n      collateral = 2;\n    }\n    let friendlyFire = 0;\n    if (friendly === enemyBase) {\n      baseDamage = damage+(collateral*2);\n      this.doDamage(enemyBase, pursuerIndex, baseDamage);\n    } else {\n      let adjacentLeft = pursuerIndex - 1;\n      let adjacentRight = pursuerIndex + 1;\n      if (friendly.pursuers[adjacentLeft] === placeHolder) {\n        while (friendly.pursuers[adjacentLeft] === placeHolder) {\n          adjacentLeft -= 1;\n        }\n      }\n      if (friendly.pursuers[adjacentRight] === placeHolder) {\n        while (friendly.pursuers[adjacentRight] === placeHolder) {\n          adjacentRight += 1;\n        }\n      }\n      if (adjacentRight < friendly.pursuers.length &&\n        friendly.pursuers[adjacentRight] != empty) {\n          this.doDamage(friendly, adjacentRight, collateral);\n      } else {\n          friendlyFire += collateral;\n      }\n      this.doDamage(friendly, pursuerIndex, damage);\n      if (adjacentLeft > -1 &&\n        friendly.pursuers[adjacentLeft] != empty) {\n          this.doDamage(friendly, adjacentLeft, collateral);\n      } else {\n          friendlyFire += collateral;\n      }\n      friendly.takeDamage(friendly.checkShields(friendlyFire));\n    }\n}\n\nPlayer.prototype.repairDrone = function(friendly, index, repairPoints, meritReward) {\n  // repair a selected ally, can choose self, award merit if not self\n  if (index === undefined) {\n    index = 0;\n  }\n  if (repairPoints === undefined) {\n    repairPoints = 3;\n  }\n  if (meritReward === undefined) {\n    meritReward = 2;\n  }\n  if (friendly.currentArmor < friendly.maxArmor) {\n    friendly.currentArmor += repairPoints;\n    if (friendly.currentArmor > friendly.maxArmor) {\n      friendly.currentArmor = friendly.maxArmor;\n    }\n    if (this != friendly) {\n      this.increaseMerit(meritReward);\n    }\n    io.sockets.emit(\"msg\", this.name + \" repairs \" + repairPoints + \" damage on \"\n                + friendly.name + \". Current armor: \"\n                + friendly.currentArmor + \"/\" + friendly.maxArmor)\n  } else {\n    console.error(friendly.name + \" is already at maximum armor.\");\n  }\n}\n\nPlayer.prototype.drawFire = function(friendly, index) {\n  // choose an ally's pursuer and bring it to you\n  io.sockets.emit(\"msg\", friendly.pursuers[index].name + \" moves from \" + friendly.name\n              + \" to \" + this.name + \".\");\n  this.increaseMerit(friendly.pursuers[index].merit);\n  game.moveCard(index, friendly.pursuers, this.pursuers);\n  game.moveCard(index, friendly.pursuerDamage, this.pursuerDamage);\n  friendly.insertPlaceholder(index);\n  this.adjustPursuerDamage();\n  friendly.adjustPursuerDamage();\n}\n\nPlayer.prototype.feint = function(friendly, pursuerIndex) {\n  // choose a tCard previously used this round and play it again\n  if (this.lastCardUsed) {\n    let card = this.lastCardUsed;\n    let action = this.lastCardUsed.cssClass;\n    io.sockets.emit(\"msg\", this.name + \" uses feint to play \" + card.name)\n    this[action](friendly, pursuerIndex);\n  } else {\n    console.error(\"No action to feint\");\n  }\n}\n\nPlayer.prototype.barrelRoll = function(friendly, pursuerIndex) {\n  if (friendly === undefined) {\n    friendly = this;\n  }\n  // move pursuer at pursuerIndex to friendly base\n  io.sockets.emit(\"msg\", this.name + \" does a barrel roll! \" + this.pursuers[pursuerIndex].name + \" now pursues \"\n              + FriendlyBase.name + \".\");\n  game.moveCard(pursuerIndex, this.pursuers, FriendlyBase.pursuers);\n  game.moveCard(pursuerIndex, this.pursuerDamage, FriendlyBase.pursuerDamage);\n  this.insertPlaceholder(pursuerIndex);\n  this.adjustPursuerDamage();\n  FriendlyBase.adjustPursuerDamage();\n}\n\nPlayer.prototype.scatterShot = function(friendly, pursuerIndex) {\n  // deal a small amount of damage to 3 adjacent targets\n  this.bomb(friendly, pursuerIndex, 2, 1)\n}\n\nPlayer.prototype.immelman = function(friendly, index) {\n  // bind click events to the player's pursuers\n  // have them choose a pursuer\n  this.missile(this, index);\n}\n\n\n\n/**************************\nPLAYER ADVANCED TACTICAL FUNCTIONS\n**************************/\n\nPlayer.prototype.medalOfHonor = function() {\n  this.effects.medalOfHonor = true;\n  io.sockets.emit(\"msg\", this.name + \" will now receive +1 merit any time they are awarded merit.\");\n}\n\nPlayer.prototype.daredevil = function() {\n  // allow player to attack enemy base if they have one or no pursuers\n  this.effects.daredevil = true;\n  io.sockets.emit(\"msg\", this.name + \" can now attack the enemy base with one pursuer.\");\n}\n\nPlayer.prototype.medic = function() {\n  this.effects.medic = true;\n  io.sockets.emit(\"msg\", this.name + \" can now repair 1 damage on a chosen ally each round.\");\n}\n\nPlayer.prototype.sharpShooter = function() {\n  this.effects.sharpShooter = true;\n  io.sockets.emit(\"msg\", this.name + \" is now better at hurting things.\");\n}\n\nPlayer.prototype.healthPack = function(friendly, index) {\n  if (index === undefined) {\n    index = 0;\n  }\n  this.repairDrone(friendly, index, 5, 0);\n}\n\nPlayer.prototype.intercept = function() {\n  enemyBase.effects.intercepted = true;\n  io.sockets.emit(\"msg\", intercept.description);\n}\n\nPlayer.prototype.jammer = function() {\n  enemyBase.effects.jammed = true;\n  io.sockets.emit(\"msg\", jammer.description);\n}\n\nPlayer.prototype.emp = function(friendly) {\n  friendly.effects.emp = true;\n  io.sockets.emit(\"msg\", this.name + \" blasts \" + friendly.name + \"'s pursuers with an EMP. \"\n              + friendly.name + \" will not be damaged this round.\");\n}\n\nPlayer.prototype.countermeasures = function() {\n  this.effects.countermeasures = true;\n  io.sockets.emit(\"msg\", this.name + \" prepares countermeasures...\")\n}\n\nPlayer.prototype.divertShields = function() {\n  this.effects.divertShields = 5;\n  io.sockets.emit(\"msg\", this.name + \" powers up shields. Next 5 damage will be negated.\")\n}\n\nPlayer.prototype.jump = function() {\n  // shake all pursuers\n  io.sockets.emit(\"msg\", this.name + \" shakes \" + this.pursuers.length\n              + \" pursuers to the friendly base.\");\n  for (let i = 0; i = this.pursuers.length; i++) {\n    enemyBase.enemyDeck.discard.push(this.pursuers.pop());\n  }\n}\n\nPlayer.prototype.hardSix = function() {\n  io.sockets.emit(\"msg\", \"Sometimes you gotta roll the hard six.\");\n  this.missile(enemyBase, undefined);\n  this.takeDamage(this.calcDamage(4));\n}\n\nPlayer.prototype.snapshot = function(friendly, pursuerIndex) {\n  io.sockets.emit(\"msg\", this.name + \" destroys \" + friendly.pursuers[pursuerIndex].name\n              + \" pursuing \" + friendly.name);\n  game.moveCard(pursuerIndex, friendly.pursuers, enemyBase.enemyDeck.discard);\n  this.insertPlaceholder(pursuerIndex);\n}\n\nPlayer.prototype.guidedMissile = function() {\n  io.sockets.emit(\"msg\", this.name + \" fires a guided missile at \" + enemyBase.name);\n  enemyBase.takeDamage(6);\n}\n\nPlayer.prototype.incinerate = function() {\n  io.sockets.emit(\"msg\", this.name + \" prepares afterburner...\");\n  this.effects.incinerator = true;\n}\n\n\n/**************************\nGENERIC FUNCTIONS TO USE TACTICAL CARDS\n**************************/\n\nPlayer.prototype.useAdvTactic = function(advTactic, friendly, pursuerIndex) {\n  // takes the index of a market card and uses that card if the player has enough merit\n  // optional arguments 'friendly' and 'pursuerIndex' defines a target for the card\n  if (friendly === undefined) {\n    friendly = this;\n  }\n  let choice = FriendlyBase.market[advTactic];\n  this.lastCardUsed = choice;\n  let action = choice.cssClass;\n  if (this.merit >= choice.cost) {\n    this.merit -= choice.cost;\n    this[action](friendly, pursuerIndex);\n    FriendlyBase.removeAdvTactic(advTactic);\n  } else {\n    io.sockets.emit(\"msg\", this.name + \" does not have enough merit.\");\n  }\n}\n\nPlayer.prototype.useTactic = function(cardIndex, friendly, pursuerIndex) {\n  // takes the index of a card in hand and uses that card\n  // optional argument 'friendly' defines a player target for the card\n  // optional argument 'pursuerIndex' defines an enemy target in friendly.hand\n  if (friendly === undefined) {\n    friendly = this;\n  }\n  if (pursuerIndex === undefined) {\n    pursuerIndex = 0;\n  }\n  let card = this.hand[cardIndex];\n  let action = card.cssClass;\n  io.sockets.emit(\"msg\", this.name + \" uses \" + card.name)\n  this[action](friendly, pursuerIndex);\n  if (action != \"feint\") {\n    this.lastCardUsed = card;\n  }\n  game.moveCard(cardIndex, this.hand, game.tacticalDeck.discard)\n  if (friendly === this) {\n    this.updateSummary();\n  } else {\n    this.updateSummary();\n    friendly.updateSummary();\n  }\n  game.update();\n}\n\nPlayer.prototype.discard = function(cardIndex, action, friendly, pursuerIndex, advIndex) {\n  if (friendly === undefined) {\n    friendly = this;\n  }\n  if (pursuerIndex === undefined) {\n    pursuerIndex = 0;\n  }\n  if (action === \"useAdvTactic\") {\n    this.useAdvTactic(advIndex, friendly, pursuerIndex);\n  } else {\n    this[action](friendly, pursuerIndex);\n  }\n  game.moveCard(cardIndex, this.hand, game.tacticalDeck.discard);\n  if (friendly === this) {\n    this.updateSummary();\n  } else {\n    this.updateSummary();\n    friendly.updateSummary();\n  }\n  game.update();\n}\n","// let friendlies = require(\"./friendlies\");\n// let tactical = require(\"./tactical\");\n// let enemies = require(\"./enemies\");\n\nconst Game = function(id, difficulty) {\n  this.name = \"Starfighter\";\n  this.difficulty = difficulty;\n  this.roundNumber = 0;\n  this.friendlies = [];\n  this.tacticalDeck = {\n    name: \"Tactical deck\",\n    cards: [],\n    discard: []\n  };\n  this.gameID = id;\n  this.win = false;\n  this.lose = false;\n}\n\nGame.prototype.moveCard = function(index, origin, destination) {\n  let removed = origin.splice(index, 1);\n  destination.push(removed[0]);\n  origin.join();\n}\n\nGame.prototype.randomIndex = function(number) {\n   let random = Math.floor(Math.random() * number);\n   return random;\n }\n\nGame.prototype.shuffle = function(deck) {\n    let randIndex, x, i;\n    let length, list;\n    if (deck.cards === undefined) {\n      length = deck.length;\n      list = deck;\n    } else {\n      length = deck.cards.length;\n      list = deck.cards;\n    }\n    for (i = length; i; i--) {\n        randIndex = Math.floor(Math.random() * i);\n        x = list[i - 1];\n        list[i - 1] = list[randIndex];\n        list[randIndex] = x;\n    }\n}\n\nGame.prototype.checkDeck = function(deck) {\n  // if deck is empty, replace with discard and shuffle\n  if (deck.cards.length === 0) {\n    while (deck.discard.length > 0) {\n      deck.cards.push(deck.discard.pop());\n    }\n    this.shuffle(deck);\n    console.log(deck.name + \" shuffled.\");\n  }\n}\n\nGame.prototype.setEmpties = function(twoP, threeP, fourP) {\n  if (this.friendlies.length === 3) {\n    return twoP;\n  } else if (this.friendlies.length === 4) {\n    return threeP;\n  } else {\n    return fourP;\n  }\n}\n\nGame.prototype.sortByMerit = function() {\n  // procedure to sort player order based on merit\n  let friendlySort = [];\n  let highestMerit = 0;\n  let firstFriendlyIndex;\n  let baseIndex;\n  let friendyIndex;\n\n  for (let i = 0; i < this.friendlies.length; i++) {\n    let friendly = this.friendlies[i];\n    // 1. Find the friendly base and set baseIndex to its location.\n    if (friendly === FriendlyBase) {\n      baseIndex = i;\n    // 2. Determine who has the highest merit.\n    } else if (friendly.merit > highestMerit) {\n      highestMerit = friendly.merit;\n      firstFriendlyIndex = i;\n    // 3. If highest merit is tied, return to default order.\n    } else if (friendly.merit === highestMerit) {\n      firstFriendlyIndex = baseIndex;\n    }\n  }\n  // Reorder the friendly list so that the player with highest merit is first\n  // Original turn order is always maintained.\n  if (firstFriendlyIndex > 0) {\n    let firstPlayer = this.friendlies.splice(firstFriendlyIndex, 1);\n    friendlySort.push(firstPlayer[0]);\n    this.friendlies.join();\n    while (this.friendlies.length > 0) {\n      if (firstFriendlyIndex < this.friendlies.length) {\n        let firstPlayer = this.friendlies.splice(firstFriendlyIndex, 1);\n        friendlySort.push(firstPlayer[0]);\n        this.friendlies.join();\n      } else {\n        friendlySort.push(this.friendlies.shift());\n      }\n    }\n    this.friendlies = friendlySort;\n  }\n  // return friendlies;\n}\n\nGame.prototype.addToDeck = function(deck, type, amount) {\n  // procedure that adds cards to a given deck\n  while (amount > 0) {\n    deck.cards.push(type);\n    amount--;\n  }\n  return deck;\n}\n\nGame.prototype.replaceCards = function(amount, deck, active) {\n  // prodecure for replacing active cards\n  let discarding = amount;\n  for (var i = amount; i > 0; i--) {\n    if (active.length > 0) {\n      deck.discard.push(active.pop());\n    }\n  }\n  for (var i = 0; i < amount; i++) {\n    this.checkDeck(deck);\n    active.push(deck.cards.pop());\n    discarding++;\n  }\n}\n\nGame.prototype.distributeEnemies = function(source) {\n  while (source.length > 0) {\n    for (let i = 0; i < this.friendlies.length; i++) {\n      let friendly = this.friendlies[i];\n      if (friendly.effects.dead) {\n        continue;\n      } else {\n        if (source.length > 0 && friendly.effects.incinerator) {\n          friendly.pursuers.push(source.pop());\n          io.sockets.emit(\"msg\", friendly.name + \" incinerates \" + friendly.pursuers[friendly.pursuers.length-1].name);\n          enemyBase.enemyDeck.discard.push(friendly.pursuers.pop());\n          friendly.effects.incinerator = false;\n        } else if (source.length > 0) {\n          friendly.pursuers.push(source.pop());\n        } else {\n          break;\n        }\n      }\n    }\n  }\n}\n\nGame.prototype.turns = function() {\n  this.turnNumber = 1;\n  while (true) {\n    // calculate amount of tactical cards left\n    let tacticalCards = 0;\n    for (let i = 0; i < this.friendlies.length; i++) {\n      let player = this.friendlies[i];\n      console.log(this.gameID + \".\" + this.roundNumber + \".\" + this.turnNumber\n                  + \": \" + player.name);\n      if (player === friendlyBase) {\n        continue;\n      } else {\n        tacticalCards += player.hand.length;\n      }\n    }\n    // break loop if there are no tactical cards left\n    if (tacticalCards === 0) {\n      break;\n    }\n    for (let i = 0; i < this.friendlies.length; i++) {\n      let player = this.friendlies[i];\n      if (player === FriendlyBase) {\n        continue;\n      } else {\n        let cardChoiceIndex = $(\"#playerHand\").children().index($(\".selected\"));\n        let cardChoice = player.hand(cardChoiceIndex);\n      }\n    }\n    this.turnNumber ++;\n  }\n}\n\n//build enemy base deck\nGame.prototype.buildEnemyBaseDeck = function() {\n  this.addToDeck(enemyBase.enemyBaseDeck, fireLight, 3);\n  this.addToDeck(enemyBase.enemyBaseDeck, fireHeavy, 2);\n  this.addToDeck(enemyBase.enemyBaseDeck, deploy, 2);\n  this.addToDeck(enemyBase.enemyBaseDeck, repair, 3);\n  let deckSize = enemyBase.enemyBaseDeck.cards.length;\n  let subDeckSize = Math.floor(deckSize/this.difficulty);\n  let splitDecks = {};\n  for (let i = 0; i < this.difficulty; i++) {\n    let key = \"d\" + i;\n    if (enemyBase.enemyBaseDeck.cards.length > subDeckSize + 1) {\n      splitDecks[key] = enemyBase.enemyBaseDeck.cards.splice(0, subDeckSize);\n    } else {\n      splitDecks[key] = enemyBase.enemyBaseDeck.cards;\n    }\n  }\n  let deckAssembled = [];\n  for (deck in splitDecks) {\n    splitDecks[deck].push(reinforce);\n    this.shuffle(splitDecks[deck]);\n    while (splitDecks[deck].length > 0) {\n      deckAssembled.push(splitDecks[deck].pop());\n    }\n  }\n  enemyBase.enemyBaseDeck.cards = deckAssembled;\n}\n\nGame.prototype.update = function() {\n  for (let i = 0; i < this.friendlies.length; i++) {\n    let friendly = this.friendlies[i];\n    friendly.updateSummary();\n  }\n  enemyBase.updateSummary();\n}\n\nGame.prototype.round = function() {\n  this.roundNumber++;\n  console.log(\"Round: \" + this.gameID + \".\" + this.roundNumber);\n  // add enemies and advanced tactics into play\n  if (this.roundNumber === 1) {\n    this.replaceCards(enemyBase.startingEnemies, enemyBase.enemyDeck,\n                      enemyBase.enemiesActive);\n    this.replaceCards(FriendlyBase.marketSize, FriendlyBase.advTactics,\n                      FriendlyBase.market);\n  } else {\n    let newEnemies = enemyBase.enemiesPerTurn;\n    if (enemyBase.effects.intercepted === true) {\n      newEnemies -= 1;\n      enemyBase.effects.intercepted = false;\n    }\n    for (let i = 0; i < newEnemies; i++) {\n      enemyBase.addEnemy();\n    }\n    if (enemyBase.effects.deploy === true) {\n      enemyBase.addEnemy();\n      enemyBase.effects.deploy = false;\n    }\n    FriendlyBase.addAdvTactic();\n  }\n\n  this.sortByMerit();\n\n  this.distributeEnemies(enemyBase.enemiesActive);\n  for (let i = 0; i < this.friendlies.length; i++) {\n    let friendly = this.friendlies[i];\n    friendly.adjustPursuerDamage();\n  }\n\n  // replace tactical cards from last turn\n  this.friendlies.forEach( function(player) {\n    if (player === FriendlyBase || player.effects.dead) {\n      return;\n    } else {\n      player.resetCardsUsed();\n      game.replaceCards(player.tacticalCardsPerTurn,\n                        game.tacticalDeck, player.hand);\n    }\n  });\n  // refresh play area\n}\n\nGame.prototype.postRound = function() {\n  // discard empty space cards and remove place holders\n  for (let i = 0; i < this.friendlies.length; i++) {\n    let friendly = this.friendlies[i];\n    for (let x = 0; x < friendly.pursuers.length; x++) {\n      let enemy = friendly.pursuers[x];\n      if (enemy === placeHolder) {\n        let removedCard = friendly.pursuers.splice(x, 1);\n        friendly.pursuers.join();\n        let removedTracker = friendly.pursuerDamage.splice(x, 1);\n        friendly.pursuerDamage.join();\n      } else if (enemy === empty) {\n        this.moveCard(x, friendly.pursuers, enemyBase.enemyDeck.discard);\n        let removedTracker = friendly.pursuerDamage.splice(x, 1);\n        friendly.pursuerDamage.join();\n      }\n    }\n  }\n\n  // deal pursuer damage to friendlies, handle cases for damage negation\n  for (let i = 0; i < this.friendlies.length; i++) {\n    let friendly = this.friendlies[i];\n    let damage = 0;\n    for (let x = 0; x < friendly.pursuers.length; x++) {\n      let enemy = friendly.pursuers[x];\n      damage += enemy.power;\n    }\n    friendly.takeDamage(friendly.checkDamageNegation(damage));\n  }\n  // replace the active enemy base card & run the new card's function\n  enemyBase.replaceEnemyBaseCard();\n  enemyBase.updateSummary();\n}\n\nGame.prototype.newRound = function() {\n  this.postRound();\n  this.round();\n}\n","// Tactical cards\nlet repairDrone = new Tactical(\"Repair drone\", \"repairDrone\", \"Remove 3 damage from a friendly (any)\");\nlet missile = new Tactical(\"Missile\", \"missile\", \"Choose a target and roll 5 combat dice\");\nlet drawFire = new Tactical(\"Draw Fire\", \"drawFire\", \"Remove a pursuer from a friendly (other) and bring it to you\");\nlet feint = new Tactical(\"Feint\", \"feint\", \"Reuse the last tactical card you used this round\");\nlet barrelRoll = new Tactical(\"Barrel Roll\", \"barrelRoll\", \"Remove a pursuer from yourself. It now pursues the friendly base\");\nlet scatterShot = new Tactical(\"Scattershot\", \"scatterShot\", \"Deal 2 damage to a single target, and 1 damage to the target on either side of it\");\nlet immelman = new Tactical(\"Immelman\", \"immelman\", \"Missile an enemy pursuing you\");\n\n// Advanced tactics\n// let medalOfHonor = new AdvTactical(\"Medal of Honor\", \"medalOfHonor\", \"Every enemy destroyed is worth 1 extra merit\", 10);\n// let daredevil = new AdvTactical(\"Daredevil\", \"daredevel\", \"Allows you to attack the EB with 1 pursuer\", 10);\n// let medic = new AdvTactical(\"Medic\", \"medic\", \"Restore 1 armor to a friendly of your choice each round\", 10);\n// let sharpShooter = new AdvTactical(\"Sharp Shooter\", \"sharpshooter\", \"Improve player accuracy rolls/add an extra die\", 10);\nlet bomb = new AdvTactical(\"Bomb\", \"bomb\", \"Deal 6 damage to a single target, and 2 damage to the target on either side of it\", 8);\nlet heatSeeker = new AdvTactical(\"Heat Seeker\", \"heatSeeker\", \"Deal 5 damage to a chosen enemy\", 5);\nlet healthPack = new AdvTactical(\"Health Pack\", \"healthPack\", \"Remove 5 damage from a friendly (any)\", 4);\nlet jammer = new AdvTactical(\"Jammer\", \"jammer\", \"Do not draw an enemy base card next round\", 6);\nlet intercept = new AdvTactical(\"Intercept\", \"intercept\", \"Draw one less enemy into play next round\", 6);\nlet emp = new AdvTactical(\"EMP\", \"emp\", \"Choose a friendly (other). Their pursuers cannot damage them this round\", 5);\nlet countermeasures = new AdvTactical(\"CNTRmeasures\", \"countermeasures\", \"Ignore x damage where x is the result of a standard combat roll\", 2);\nlet divertShields = new AdvTactical(\"Divert Shields\", \"divertShields\", \"Keep this card. It absorbs the next 5 damage you take\", 3);\nlet jump = new AdvTactical(\"Jump\", \"jump\", \"Shake all your pursuers this round to discard\", 15);\nlet hardSix = new AdvTactical(\"Roll the hard six\", \"hardSix\", \"If pursued, missile the enemy base and take damage of a standard combat roll\", 6);\nlet snapshot = new AdvTactical(\"Snapshot\", \"snapshot\", \"Remove an enemy from play (no merit awarded)\", 7);\nlet guidedMissile = new AdvTactical(\"Guided Missile\", \"guidedMissile\", \"Deal 6 damage to the enemy base regardless of pursuers\", 10);\nlet incinerate = new AdvTactical(\"Incinerate\", \"incinerate\", \"Destroy the first enemy drawn to you next round\", 7);\n\n\n// define enemy types\nlet ace = new Enemy(\"Ace\",\"ace\",6,4,5,4);\nlet heavy = new Enemy(\"Heavy\",\"heavy\",5,3,3,3);\nlet medium = new Enemy(\"Medium\",\"medium\",4,2,4,2);\nlet light = new Enemy(\"Light\",\"light\",3,2,4,1);\nlet empty = new Enemy(\"Empty space\",\"emptySpace\",0,0,0,0);\nlet placeHolder = new Enemy(\"Destroyed\",\"destroyed\",0,0,0,0);\n\n// define enemy base cards\nlet fireLight = new EnemyBaseCard(\"Fire light weapons\", \"fireLight\", \"Friendly base takes 3 damage\");\nlet fireHeavy = new EnemyBaseCard(\"Fire heavy weapons\", \"fireHeavy\", \"Friendly base takes 5 damage\");\nlet deploy = new EnemyBaseCard(\"Deploy\", \"deploy\", \"Draw an extra enemy card into play in the next round\");\nlet repair = new EnemyBaseCard(\"Repairs\", \"repair\", \"Enemy base repairs 5 armor.\");\nlet reinforce = new EnemyBaseCard(\"Reinforcements\", \"reinforce\", \"Increase the amount enemies that enter the fray each turn by 1\");\n\nlet enemyBase = new EnemyBase();\n\n// define friendlies\nlet FriendlyBase = new Friendly(\"FriendlyBase\", \"Friendly Base\", 30);\nlet Player1;\nlet Player2;\nlet Player3;\nlet Player4;\n\nlet game = new Game();\n\nlet reset = function() {\n  FriendlyBase = new Friendly(\"FriendlyBase\", \"Friendly Base\", 30);\n  Player1 = null;\n  Player2 = null;\n  Player3 = null;\n  Player4 = null;\n\n  game = new Game();\n}\n\nlet buildGame = function(game) {\n  // build tactical deck\n  game.addToDeck(game.tacticalDeck, missile, 6);\n  game.addToDeck(game.tacticalDeck, scatterShot, 4);\n  game.addToDeck(game.tacticalDeck, drawFire, 3);\n  game.addToDeck(game.tacticalDeck, feint, 4);\n  game.addToDeck(game.tacticalDeck, barrelRoll, 2);\n  game.addToDeck(game.tacticalDeck, immelman, 3);\n  game.addToDeck(game.tacticalDeck, repairDrone, 2);\n\n  game.tacticalDeck.size = game.tacticalDeck.cards.length;\n\n  game.shuffle(game.tacticalDeck);\n\n  // build advanced tactical deck\n  game.addToDeck(FriendlyBase.advTactics, healthPack, 5);\n  game.addToDeck(FriendlyBase.advTactics, heatSeeker, 6);\n  game.addToDeck(FriendlyBase.advTactics, bomb, 3);\n  game.addToDeck(FriendlyBase.advTactics, snapshot, 3);\n  game.addToDeck(FriendlyBase.advTactics, guidedMissile, 3);\n  game.addToDeck(FriendlyBase.advTactics, incinerate, 3);\n  game.addToDeck(FriendlyBase.advTactics, jammer, 6);\n  game.addToDeck(FriendlyBase.advTactics, intercept, 3);\n  game.addToDeck(FriendlyBase.advTactics, emp, 2);\n  game.addToDeck(FriendlyBase.advTactics, countermeasures, 3);\n  game.addToDeck(FriendlyBase.advTactics, divertShields, 2);\n  game.addToDeck(FriendlyBase.advTactics, jump, 1);\n  game.addToDeck(FriendlyBase.advTactics, hardSix, 4);\n\n  FriendlyBase.advTactics.size = FriendlyBase.advTactics.cards.length;\n\n  game.shuffle(FriendlyBase.advTactics);\n\n  // build enemy deck\n  game.addToDeck(enemyBase.enemyDeck, ace, 4);\n  game.addToDeck(enemyBase.enemyDeck, heavy, 9);\n  game.addToDeck(enemyBase.enemyDeck, medium, 12);\n  game.addToDeck(enemyBase.enemyDeck, light, 15);\n  game.addToDeck(enemyBase.enemyDeck, empty, game.setEmpties(8, 4, 0));\n\n  enemyBase.enemyDeck.size = enemyBase.enemyDeck.cards.length;\n\n  game.shuffle(enemyBase.enemyDeck);\n\n  // build enemy base deck\n  game.buildEnemyBaseDeck();\n\n  enemyBase.enemyBaseDeck.size = enemyBase.enemyBaseDeck.cards.length;\n\n  // set rules dependent on amount of players\n  enemyBase.startingEnemies = game.friendlies.length * 2;\n  enemyBase.enemiesPerTurn = game.friendlies.length;\n}\n\nlet launchGame = function() {\n  game.round();\n}\n","let root = __dirname;\nlet port = process.env.PORT || 8080;\nlet http = require('http');\nlet express = require('express');\nlet bodyParser = require('body-parser');\nlet mongoose = require('mongoose');\nlet session = require('express-session');\nlet app = express();\nlet server = http.createServer(app);\nlet socketio = require('socket.io');\nlet io = socketio(server);\nlet User = require('./js/models/user');\nlet GameSession = require('./js/models/game');\nlet MongoStore = require('connect-mongo')(session);\nlet currentUser;\nlet currentGame;\n\n// mongodb connection\nmongoose.connect('mongodb://localhost:27017/starfire');\nlet db = mongoose.connection;\n\n// mongo error\ndb.on('error', console.error.bind(console, 'connection error:'));\n\n// use sessions for tracking logins\napp.use(session({\n  secret: 'Do a barrel roll!',\n  resave: true,\n  saveUninitialized: false,\n  store: new MongoStore({\n    mongooseConnection: db\n  })\n}));\n\n// make user ID available in app and templates\napp.use(function (req, res, next) {\n  res.locals.currentUser = req.session.userId;\n  res.locals.currentGame = req.session.gameId;\n  currentUser = req.session.userId;\n  currentGame = req.session.gameId;\n  next();\n})\n\n// parse incoming requests\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// serve static files from root\napp.use(express.static(root));\n\n// view engine setup\napp.set('view engine', 'pug');\napp.set('views', __dirname + '/views');\n\n// include routes\nlet routes = require('./js/routes/index');\napp.use('/', routes);\n\n// 404 handler\napp.use(function(req, res, next) {\n  var err = new Error('File Not Found');\n  err.status = 404;\n  next(err);\n});\n\n// error handler\napp.use(function(err, req, res, next) {\n  if (currentUser) {\n    let backUrl = req.header('Referer') || '/login';\n    res.status(err.status || 500);\n    res.render('error', {\n      statusMessage: err.message || 'There was en error processing your request',\n      error: {},\n      backPrompt: 'Go back',\n      backUrl: backUrl\n    });\n  } else {\n    res.status(err.status || 500);\n    res.render('error', {\n      statusMessage: err.message || 'There was en error processing your request',\n      error: {},\n      backPrompt: 'Go to login',\n      backUrl: '/login'\n    });\n  }\n\n});\n\nserver.listen(port, () => console.log('Ready. Listening at http://localhost:' + port));\n\n// let nsps = [];\n// getGameSessions(function(err, gameSessions) {\n//   if (err) {\n//     console.error(err);\n//   }\n//   gameSessions.forEach(function(gameSession) {\n//     if (gameSession._id != gameSession.gameName) {\n//       nsps.push(gameSession._id);\n//     }\n//   })\n//   console.log(nsps);\n//   nsps.forEach(function(nsp) {\n//     io.of('/' + nsp).on('connection', onConnection);\n//   });\n// });\n\n// game logic\nio.on('connect', onConnection);\n\nlet waitingPlayer1;\nlet waitingPlayer2;\nlet waitingPlayer3;\n\nlet currentTurn;\n\nlet startTime;\n\nlet gameData = {\n  turn: currentTurn,\n  game: game,\n  FriendlyBase: FriendlyBase,\n  Player1: Player1,\n  Player2: Player2,\n  enemyBase: enemyBase\n}\n\nfunction clearSockets() {\n  waitingPlayer1 = null;\n  waitingPlayer2 = null;\n  waitingPlayer3 = null;\n}\n\nfunction createGame(sessionName) {\n  let nsp = io.of('/' + sessionName);\n  nsp.on('connection', onConnection);\n}\n\nfunction getUser(userId, callback) {\n  User.findById(userId, function(error, user) {\n    if (error) {\n      callback(err, null);\n    } else {\n      callback(null, user);\n    }\n  });\n}\n\nfunction getGameSession(gameId, callback) {\n  GameSession.findById(gameId, function(error, game) {\n    if (error) {\n      callback(err, null);\n    } else {\n      callback(null, game);\n    }\n  });\n}\n\nfunction getGameSessions(callback) {\n  GameSession.find({}, function(error, gameSessions) {\n    if (error) {\n      callback(err, null);\n    } else {\n      callback(null, gameSessions);\n    }\n  });\n}\n\nfunction onConnection(socket) {\n  let join = function(player) {\n    if(currentGame) {\n      socket.join(currentGame);\n      console.log('user joined room '+ currentGame);\n    }\n    if (currentUser) {\n      getUser(currentUser, function(err, user) {\n        if (err) {\n          console.error(err);\n        }\n        player.name = user.callsign;\n        GameSession.findById(currentGame, function(err, gameSession) {\n          if (err) {\n            console.error(err);\n          }\n          gameSession.state.friendlies.push(player);\n          gameSession.save();\n        });\n        socket.emit('assign', player);\n        socket.on('turn', turn);\n        socket.on('chat', function(message) {\n          io.to(currentGame).emit('chatMessage', message);\n        });\n        io.to(currentGame).emit('msg', player.name + ' joined as ' + player.id);\n        socket.on('disconnect', function() {\n          GameSession.findById(currentGame, function(err, gameSession) {\n            if (err) {\n              console.error(err);\n            }\n            if (gameSession.locked) {\n              player.effects.dead = true;\n            } else {\n              io.to(currentGame).emit('msg', player.name + ' left.');\n              if (waitingPlayer3) {\n                waitingPlayer3 = null;\n              } else if (waitingPlayer2) {\n                waitingPlayer2 = null;\n                io.to(currentGame).emit('closeGame');\n                io.to(currentGame).emit('msg', 'Waiting for second player...')\n              } else {\n                waitingPlayer1 = null;\n              }\n              gameSession.state.friendlies.splice(game.friendlies.indexOf(player));\n              gameSession.state.friendlies.join();\n              for (person in gameSession.users) {\n                if (gameSession.users[person] === user.callsign) {\n                  gameSession.users[person] = undefined;\n                  gameSession.players -= 1;\n                }\n              }\n              if (gameSession.players === 0) {\n                gameSession.gameName = gameSession._id;\n                gameSession.state.game = [];\n                gameSession.state.friendlies = [];\n                gameSession.meta.aborted = true;\n                console.log('Game id:' + gameSession._id + ' aborted');\n              }\n              gameSession.save(function(err) {\n                if (err) {\n                  console.error(err);\n                } else {\n                  console.log('user removed');\n                }\n              });\n            }\n          });\n          socket.leave(currentUser)\n          console.log('user disconnected');\n        });\n      });\n    }\n  }\n  let addPlayer = function() {\n    GameSession.findById(currentGame, function(err, gameSession) {\n      if (err) {\n        console.error(err);\n      }\n      if (!gameSession.state.friendlies.includes(Player2)) {\n        Player2 = new Player('Player2');\n        join(Player2);\n      } else if (!gameSession.state.friendlies.includes(Player3)) {\n        Player3 = new Player('Player3');\n        join(Player3);\n      } else {\n        Player4 = new Player('Player4');\n        join(Player4);\n      }\n    });\n  }\n  if (waitingPlayer3) {\n    waitingPlayer4 = socket;\n    addPlayer();\n    io.to(currentGame).emit('msg', 'Game full');\n    clearSockets();\n  } else if (waitingPlayer2) {\n    waitingPlayer3 = socket;\n    addPlayer();\n  } else if (waitingPlayer1) {\n    waitingPlayer2 = socket;\n    addPlayer();\n    io.to(currentGame).emit('msg', 'Game ready');\n    io.to(currentGame).emit('openGame');\n  } else {\n    waitingPlayer1 = socket;\n    GameSession.findById(currentGame, function(err, gameSession) {\n      if (err) {\n        console.error(err);\n      }\n      FriendlyBase = new Friendly(\"FriendlyBase\", \"Friendly Base\", 30);\n      gameSession.state.friendlies.push(FriendlyBase);\n      gameSession.save();\n    });\n    Player1 = new Player('Player1');\n    join(Player1);\n    socket.emit('msg', 'Waiting for second player...');\n    socket.emit('firstPlayer');\n    socket.on('startGame', function() {\n      //protects from premature game start\n      GameSession.findById(currentGame, function(err, gameSession) {\n        if (err) {\n          console.error(err);\n        }\n        if (gameSession.state.friendlies.includes(Player2)) {\n          let update = { 'meta.locked': true, 'meta.startTime': new Date(), 'meta.endTime': new Date() };\n          GameSession.update(gameSession, update, function() {\n            io.to(currentGame).emit('start');\n            clearSockets();\n            let game = new Game(gameSession._id, gameSession.difficulty);\n            game.friendlies = gameSession.state.friendlies;\n            buildGame(game);\n            updateObjects();\n          });\n        }\n      });\n    });\n  }\n}\n\nfunction updateObjects() { //needs update for database version\n  game.update();\n  gameData = {\n    turn: currentTurn,\n    game: game,\n    FriendlyBase: FriendlyBase,\n    enemyBase: enemyBase\n  }\n  if (game.friendlies.includes(Player1)) {\n    gameData.Player1 = Player1;\n  }\n  if (game.friendlies.includes(Player2)) {\n    gameData.Player2 = Player2;\n  }\n  if (game.friendlies.includes(Player3)) {\n    gameData.Player3 = Player3;\n  }\n  if (game.friendlies.includes(Player4)) {\n    gameData.Player4 = Player4;\n  }\n  io.to(currentGame).emit('update', gameData);\n}\n\nfunction turn(data) { // needs update for database version\n  let specs = JSON.parse(data);\n  let getPlayer = function(id) {\n    if (id === 'Player1') {\n      return Player1;\n    } else if (id === 'Player2') {\n      return Player2;\n    } else if (id === 'Player3') {\n      return Player3;\n    } else if (id === 'Player4') {\n      return Player4;\n    } else if (id === 'FriendlyBase') {\n      return FriendlyBase;\n    } else if (id === 'enemyBase') {\n      return enemyBase;\n    }\n  }\n  let friendly = undefined;\n  let player = getPlayer(specs.player.id);\n  if (specs.friendly !== undefined) {\n    friendly = getPlayer(specs.friendly.id);\n  }\n  if (specs.button === 'use') {\n    player.useTactic(specs.cardIndex, friendly, specs.pursuerIndex);\n  } else {\n    player.discard(specs.cardIndex, specs.button, friendly,\n                                          specs.pursuerIndex,\n                                          specs.purchaseIndex);\n  }\n\n  let cardsLeft = 0;\n  game.friendlies.forEach((friendly) => {\n    if (friendly === FriendlyBase) {\n      cardsLeft += 0;\n    } else {\n      cardsLeft += friendly.hand.length;\n    }\n  });\n  if (cardsLeft === 0) {\n    game.postRound();\n    game.round();\n    currentTurn = 0;\n  } else {\n    currentTurn += 1;\n  }\n  let resetTurns = function() {\n    if (currentTurn >= game.friendlies.length\n        || (currentTurn === game.friendlies.length-1\n        && game.friendlies[currentTurn].id === 'FriendlyBase')\n        || (currentTurn === game.friendlies.length-1\n        && game.friendlies[currentTurn].effects.dead)) {\n      currentTurn = 0;\n    }\n  }\n  resetTurns();\n  while (game.friendlies[currentTurn].id === 'FriendlyBase'\n      || game.friendlies[currentTurn].effects.dead) {\n    currentTurn += 1;\n    resetTurns();\n  }\n  if (game.win) {\n    updateObjects();\n    io.to(currentGame).emit('end', 'Victory!');\n    reset();\n    getGameSession(currentGame, function(err, gameSession) {\n      if (err) {\n        console.error(err);\n      }\n      let endTime = new Date();\n      let ms = endTime - gameSession.meta.startTime;\n      let min = Math.round(ms/1000/60);\n      gameSession.gameName = gameSession._id;\n      gameSession.meta.rounds = gameSession.state.game.roundNumber;\n      gameSession.meta.won = true;\n      gameSession.meta.endTime = endTime;\n      gameSession.meta.elapsedTime = min;\n      gameSession.save(function(err, updated) {\n        if (err) {\n          console.error(err);\n        }\n        for (let i = 1; i < 5; i++) {\n          let user = 'user' + i;\n          if (gameSession.users[user]) {\n            let query = { callsign: gameSession.users[user] };\n            User.find(query, function(err, player) {\n              let wins = player.meta.wins + 1;\n              player.meta.wins = wins;\n              if (wins = 21) {\n                player.meta.rank = 'Admiral';\n              } else if (wins = 18) {\n                player.meta.rank = 'Commander';\n              } else if (wins = 15) {\n                player.meta.rank = 'Colonel';\n              } else if (wins = 12) {\n                player.meta.rank = 'Lt. Colonel';\n              } else if (wins = 9) {\n                player.meta.rank = 'Major';\n              } else if (wins = 6) {\n                player.meta.rank = 'Captain';\n              } else if (wins = 3) {\n                player.meta.rank = 'Lieutenant';\n              }\n              player.save(function(err, updated) {\n                if (err) {\n                  console.error(err);\n                } else {\n                  console.log(gameSession.users[user] + \" updated\");\n                  if (updated.meta.wins < 22 && updated.meta.wins%3 === 0) {\n                    console.log(updated.callsign + \" promoted to \" + updated.meta.rank);\n                  }\n                }\n              });\n            });\n          } else {\n            continue;\n          }\n        }\n      });\n    });\n  } else if (game.lose) {\n    updateObjects();\n    io.to(currentGame).emit('end', 'Defeat!');\n    reset();\n    getGameSession(currentGame, function(err, gameSession) {\n      if (err) {\n        console.error(err);\n      }\n      let endTime = new Date();\n      let ms = endTime - gameSession.meta.startTime;\n      let min = Math.round(ms/1000/60);\n      gameSession.gameName = gameSession._id;\n      gameSession.meta.rounds = game.roundNumber;\n      gameSession.meta.lost = true;\n      gameSession.meta.endTime = endTime;\n      gameSession.meta.elapsedTime = min;\n      gameSession.save(function(err, updated) {\n        if (err) {\n          console.error(err);\n        }\n        for (let i = 1; i < 5; i++) {\n          let user = 'user' + i;\n          if (gameSession.users[user]) {\n            let query = { callsign: gameSession.users[user] };\n            let update = { $inc: { 'meta.losses': 1 }};\n            User.update(query, update, function() {\n              console.log(gameSession.users[user] + \" updated\");\n            });\n          } else {\n            continue;\n          }\n        }\n      });\n    });\n  } else {\n    updateObjects();\n  }\n}\n"]}